#include <cstdio>

// 흔하지는 않지만 순환적인 방법이 더 빠른 예도 있다
// 숫자 x의 n 거듭제곱 값인 x^n을 구하는 함수를 작성해보자

// C++ 의 수학 라이브러리 함수를 사용하지 않고 반복문으로 작성시
double slowPower(double x, int n)
{
	double result = 1.0;
	for (int i = 0; i < n; i++)
		result = result * x;

	return result;

}

// x^n = (x^2)^n/2 의 공식을 이용하여
// 짝수인 경우 x^2를 먼저 계산한 후에 이 값을 n/2승 하는 것이다
// 홀수인 경우에는 x^2를 (n-1)/2승 하고 여기에 x를 곱해주면 마찬가지가 된다
// (인터넷, 책272p 참고)

// 이렇게 순환적으로 함수를 호출할 때마다 문제의 크기가 줄어든다
// 문제의 크기가 하나씩 줄어드는 것이 아니라 절반씩 줄어든다
// 거듭제곱을 구하는 순환 호출의 예(인터넷, 책 273p 참고)

// slowPower() 함수의 수행시간을 clock 함수로 측정하여 보면 2^500을 1000000번 계산시키는데 7.11초가 걸린다
// 반면 순환적인 power() 함수는 0.47초가 걸린다

// 두개 함수의 시간복잡도를 보면
// 매 루프마다 한 번의 곱셈이 필요하고 루프의 개수는 정확이 n이 되므로
// 반복적인 함수는 O(n)

// 한 번의 순환 호출이 일어날 때마다 1번의 곱셉과 1번의 나눗셈이 일어나므로 전체 연산의 개수는 k=log2n에 비례하게 된다
// 순환적인 함수는 O(log2n)
double power(double x, int n)
{
	if (n == 0) 
		return 1;
	else if ((n % 2) == 0) // n이 짝수인 경우
		return power(x*x, n / 2);
	else // n이 홀수인 경우
		return x * power(x*x, (n - 1) / 2);
}

int main()
{
	printf("%f\n", power(2, 64));

	return 0;
}