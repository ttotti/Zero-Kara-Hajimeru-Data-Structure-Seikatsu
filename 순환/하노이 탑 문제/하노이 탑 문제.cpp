#include <cstdio>


// 하노이 탑
// 고대 인도의 이 전설의 탑 '하노이의 탑(The Tower of Hanoi)' 이라고 부른다

// 규칙
// 한 번에 하나의 원판만 이동할 수 있다
// 맨 위에 있는 원판만 이동할 수 있다
// 크기가 작은 원판 위에 큰 원판이 쌓일 수 없다
// 중간의 막대를 임시적으로 이용할 수 있으나 앞의 조건들을 지켜야 한다

// 일단 하노이의 탑은 수학적인 논리로 n개의 원반을 한쪽 기둥에서 다른 쪽으로 옮기는데 걸리는 최소 횟수는 (2^n - 1) 번이다(점화식)
// 일단 재귀호출을 이해하기 위해 수학적으로 접근하지 말고 실행 순서를 트리구조로 전개하고 보면 쉽다(분활정복)

// 즉 n-1개의 원판을 항상 A에서 C로 옮긴다고 생각했고(A->C) 이를 위해 봉을 옮기면 되는것이다('봉을 옮긴다' 이게 포인트!)
// (인터넷, 책277p 참고)
void hanoiTower(int n, char from, char tmp, char to)
{
	if (n == 1)
		printf("원판 1을 %c에서 %c으로 옮긴다\n", from, to);
	else
	{
		hanoiTower(n - 1, from, to, tmp);
		printf("원판 %d을 %c에서 %c으로 옮긴다\n", n, from, to);
		hanoiTower(n - 1, tmp, from, to);
	}
}

int main()
{
	hanoiTower(3, 'A', 'B', 'C');

	return 0;
}


// 추가
// 반복적인 형태로 바꾸기 어려운 순환

// 팩토리얼 예제에서 다음 문장들의 차이는 무엇일까?
// 1. return n * factorial(n - 1)
// 2. return factorial(n - 1) * n

// 1번은 꼬리 순환 - 순환 호출이 순환 함수의 맨 끝에서 이루어지는 형태의 순환이다
// 꼬리 순환의 경우 알고리즘은 쉽게 반복적인 형태로 변환이 가능하다

// 2번은 머리 순환 - 2번의 머리 순환의 경우나 위의 하노이의 탑 문제처럼 여러 군데에서 자기 자신을 호출하는 경우
// 머리 순환은 쉽게 반복적인 코드로 바꿀 수 없다
// 물론 이런 경우에 명시적인 스택을 만들어서 순환을 시뮬레이션 할 수는 있다

// 만약 동일한 알고리즘을 꼬리 순환과 머리 순환 양쪽으로 모두 표현할 수 있다면 당연히 꼬리 순환으로 작성해야 한다