

// 기수 정렬은 입력 데이터에 대해서 어떤 비교 연산도 실행하지 않고 데이터를 정렬할 수 있는 색다른 정렬 기법이다
// 다른 방법들이 O(n log2 n) 이라는 정렬의 이론적인 하한선을 깰 수 없는데 비해 기수 정렬은 이 하한선을 깰 수 있는 유일한 기법이다
// 사실 기수 정렬은 O(kn) 의 시간 복잡도를 가지는데 대부분 k<4 이하이다
// 기수 정렬은 추가적인 메모리를 필요로 하는데, 이런 단점을 감안하더라도 다른 방법들 보다 빠르기 때문에 사당히 인기 있는 정렬 기법 중의 하나이다

/*
	기수(radix) 란 숫자의 자릿수이다,
	예를 들면 숫자 42는 4와 2의 두 개의 자릿수를 가지고 이것이 기수가 된다
	기수 정렬은 이러한 자릿수의 값에 따라서 정렬하기 때문에 기수 정렬 이라는 이름을 얻었다
	기수 정렬은 다단계 정렬이다
	단계의 수는 데이터의 자릿수의 개수와 일치한다

	리스트 (8, 2, 7, 3, 5) 가 있다고 하면
	십진수에서는 각 자릿수가 0에서 9까지의 값만 가지는 것에 착안하면
	다음과 같이 10개의 버켓을 만들어서 입력 데이터를 값에 따라 상자에 넣는다
	각 왼쪽 상자부터 순차적으로 버킷 안에 들어 있는 숫자를 순차적으로 읽는다
	그러면 정렬된 숫자 리스트 (2, 3, 5, 7, 8)를 얻을 수 있다
	이 과정에서 비교 연산은 전혀 사용되지 않고 각 자릿수의 값에 따라 버킷에 넣고 빼는 동작을 되풀이 했을 뿐이다

	여러 자리로 이루어진 수는 어떻게 정렬하는가?
	숫자 리스트 (28, 93, 39, 81, 62, 72, 38, 26) 를 예로 들면
	0에서 99번 까지 번호가 매겨진 100개의 버킷을 사용하여 앞에서와 마찬가지로 정렬을 할 수 있다
	그러나 보다 효과적인 방법이 있다
	즉 1의 자릿수와 10의 자릿수를 따로 사용하여 정렬을 하는 방법이다
	이렇게 하면 10개의 버킷만으로도 2자리 정수를 정렬할 수 있다
	먼저 낮은 자릿수로 정렬한 다음 차츰 높은 자릿수로 정렬하면 된다

	예를 들어 (28, 93, 39, 81, 62, 72, 38, 26)을 먼저 10의 자릿수를 먼저 사용하고 1의 자릿수를 나중에 생각하면
	(28, 26, 39, 38, 61, 72, 81, 93) -> (61, 81, 72, 93, 26, 28, 38, 39) 가 되어 잘못된 결과가 나온다
	그러나 1의 자리수를 먼저 사용하면, 같은 버킷을 사용하더라도
	(81, 62, 72, 93, 26, 28, 38, 39) -> (26, 28, 38, 39, 62, 72, 81, 93) 이 되어 정렬하는 것이 가능해진다
*/

// 기수 정렬의 분석
/*
	만약 입력 리스트가 n개의 정수를 가지고 있다고 하면 알고리즘의 내부 루프는 n번 반복될 것이다
	만약 각 정수가 d개의 자릿수를 가지고 있다고 하면 외부 루프는 d번 반복된다
	따라서 기수 정렬은 O(d*n)의 시간 복잡도를 가진다
	시간 복잡도가 d에 비례하기 때문에 기수 정렬의 수행 시간은 정수의 크기와 관련이 있다
	그러나 일반적으로 컴퓨터 안에서의 정수의 크기를 제한된다
	32비트 컴퓨터의 경우에는 대개 10개 정도의 자릿수만을 가지고 된다
	따라서 일반적으로 d는 n에 비하여 아주 작은 수가 되므로 기수 정렬은 O(n) 이라고 하여도 무리가 없다

	따라서 기수 정렬은 다른 정렬 방법에 비하여 빠른 수행 시간에 정렬을 마칠 수 있다
	그러나 문제점은 정렬에 사용되는 키값이 자연수로 표현되어야만 적용이 가능하다는 것이다
	만약 예를 들어 실수나 한글, 한자 등으로 이루어진 키값을 이 방법으로 정렬하고자 할 경우 매우 많은 버킷이 필요하게 되므로 적용이 불가능하다
	다른 정렬 방법들은 모든 종류의 키 형태에 적용될 수 있음을 기억하라
*/

// 기수 정렬 알고리즘
/*
	LSD(least significant digit) 는 가장 낮은 자릿수 이고
	MSD(most significant digit) 는 가장 높은 자릿수 이다 

	각각 버킷에서 먼저 들어간 숫자들은 먼저 나와야 한다
	따라서 각각의 버킷은 큐로 구현되어야 한다
	큐로 구현되어야 리스트 상에 있는 요소들의 상대적인 순서가 유지된다
	버킷에 숫자를 집어넣는 연산은 큐의 삽입 연산이 되고
	버킷에서 숫자를 읽는 연산은 삭제 연산으로 대치하면 된다

	버킷의 개수는 키의 표현 방법과 밀접한 관계가 있다
	만약 키를 2진법을 사용하여 표현하고 정렬한다면 버킷은 2개만 있으면 된다
	또한 키가 알파벳 문자로 되어 있다면 26개의 버킷이 필요하다
	기수 정렬은 숫자를 10진법으로 생각하면 10개의 버킷을 이용하면 되지만, 다른 방법도 있다
	예를 들어, 32비트의 정수를 8비트씩 나누어 적용할 수 있다
	이 경우 필요한 버킷의 수는 256개가 된다, 대신에 필요한 패스의 수는 4개로 십진수 표현보다 줄어든다
*/

// 큐 사용
#include "CircularQueue.h"

static void PrintArray(int arr[], int n, const char* str);

// 십진수의 경우 10개의 버킷이 필요하므로 큐도 10개의 큐가 필요하다
#define BUCKETS 10
// 정렬에는 2자리수로 된 자연수만을 취급한다
#define DIGITS 2

void radixSort(int list[], int n)
{
	// 순서대로 0번 큐는 0이 들어간 숫자를 저장, 1번 큐는 1이 들어간 숫자를 저장.. 9번 큐에는 9가 들어간 숫자를 저장한다
	CircularQueue queues[BUCKETS];
	int factor = 1;

	for (int d = 0; d < DIGITS; d++)
	{
		// 데이터들을 자릿수에 따라 큐에 삽입
		for (int i = 0; i < n; i++)
		{
			queues[(list[i] / factor) % 10].enqueue(list[i]);
		}

		// 버킷에서 꺼내어 list로 합친다
		for (int b = 0,i = 0; b < BUCKETS; b++)
		{
			while (!queues[b].isEmpty())
			{
				list[i++] = queues[b].dequeue();
			}
		}

		// 그 다음 자릿수로 간다
		factor *= 10;

		PrintArray(list, n, "Radix....");
	}
}

// 배열을 화면에 보기 좋게 출력하는 함수, 디폴트 매개변수 사용
// static 으로 선언하여 캡슐화 하였다 (static 으로 선언된 함수는 선언한 파일안에서만 사용할 수 있다)
static void PrintArray(int arr[], int n, const char* str = "Array")
{
	printf("%s = ", str);

	for (int i = 0; i < n; i++)
		printf("%3d", arr[i]);

	printf("\n");
}

// 랜덤 함수를 이용하여 int 배열을 0 ~ max-1 의 값으로 무작위로 채우는 함수
// static 으로 선언하여 캡슐화 하였다 (static 으로 선언된 함수는 선언한 파일안에서만 사용할 수 있다)
static void initRandom(int list[], int n, int max = 100)
{
	for (int i = 0; i < n; i++)
	{
		list[i] = rand() % max;
	}
}

int main()
{
	int list[16];
	int n = 16;

	initRandom(list, n);

	// 정렬 전 배열 내용을 출력
	PrintArray(list, n, "Original ");

	radixSort(list, n);

	// 정렬 후 배열 내용을 출력
	PrintArray(list, n, "RadixSort");

	return 0;
}