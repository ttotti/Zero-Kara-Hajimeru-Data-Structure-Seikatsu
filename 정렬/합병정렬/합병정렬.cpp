#include <cstdio>
#include <cstdlib>
#include <ctime>

// 합병 정렬(merge sort)은 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 리스트를 합하여 전체가 정렬된 리스트를 만드는 방법이다
// 이것은 분할 정봅 기법에 바탕을 두고 있는데, 하나의 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다
// 분리된 문제가 아직도 해결하기 어렵다면, 즉 충분히 작지 않다면 분할 정복 방법을 연속하여 다시 적용한다,
// 분할 정봅 기법은 대개 순환 호출을 이용하여 구현된다

// 합병 정렬은 다음의 단계들로 이루어진다
/*
	분할(Divide)  : 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다
	정복(Conquer) : 부분 배열을 정렬한다, 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용하여 다시 분할 정복 기법을 적용한다
	결합(Combine) : 정렬된 부분 배열들을 하나의 배열에 통합한다
*/

// 다음과 같은 배열이 있다고 하면
/*
	27, 10, 12, 20, 25, 13, 15, 22

	1. 분할 : 배열을 27, 10, 12, 20 과 25, 13, 15, 22 2개의 부분 배열로 나눈다
 	2. 정복 : 부분 배열을 정렬하여 10, 12, 20, 27 과 13, 15, 22, 25 를 얻는다
	3. 결합 : 부분 배열을 통합하여 10, 12, 13, 15, 20, 22, 25, 27 을 얻는다

	이를 합병 정렬 함수를 순환적으로 호출한다
	부분 배열의 요소가 하나가 되면 이미 정렬된 것으로 볼 수 있다
*/

// 자세한 그림과 설명은 책 523p, 인터넷을 참고한다

// 합병 정렬의 복잡도 분석
// 합병 정렬은 순환 호출 구조로 되어 있다, 따라서 레코드의 개수 n이 2의 거듭제곱이라고 가정하면 2^3 -> 2^2 -> 2^1 -> 2^0 순으로 줄어들어 순환 호출의 깊이가 3임을 알 수 있다
// 따라서 n = 2^k 라고 하면 2^k -> 2^k-1 -> ... 2^0 이 되어 순환의 깊이가 k가 된다 이때 k = log2 n 가 된다

// 배열이 부분 배열로 나누어지는 단계에서는 비교 연산이나 이동 연산은 수행되지 않는다
// 부분 배열이 합쳐지는 merge 함수에서 비교 연산과 이동 연산이 수행되는 것이다
// 순환 호출의 깊이만큼의 합병 단계가 필요하다, 즉 하나의 합병 단계에서는 최대 n번의 비교 연산이 필요함을 알 수 있다
// 이러한 합병 단계가 k = log2 n 번 만큼 있으므로 총 비교 연산은 최대 n log2 n 번 필요하다
// 이동 연산은 하나의 합병 단계에서 보면 임시 배열에 복사했다가 다시 가져와야 되므로
// 이동 연산은 총 부분 배열에 들어 있는 요소의 개수가 n인 경우 레코드의 이동이 2n번 발생하므로 하나의 합병 단계에서 2n개가 필요하다 
// 따라서 log2 n 개의 합병 단계가 필요하므로 총 2n log2 n 개의 이동 연산이 필요하다 결론적으로 합병 정렬은 O(n log2 n)의 복잡도를 가지는 알고리즘이다

// 합병 정렬의 특징은 입력 데이터가 어떻게 이루어져 있는지에 상관없이,
// 즉 최악, 평균, 최선의 경우에도 모두 동일한 시간에 정렬된다는 것이다
// 합병 정렬의 단점은 임시 배열이 필요한 것과, 만약 레코드들의 크기가 큰 경우에는 이동횟수가 많아 큰 시간적 낭비가 발생 할 수 있다는 것이다
// 그러나 레코드 자체를 이동하지 않고 포인터(또는 링크 인덱스)만 이동하면 이런 문제가 해결된다
// 따라서 합병 정렬은 매우 효율적인 정렬 방법의 하나이다

// 즉 합병 정렬은 포인터를 사용하여 구현하는 것을 권장한다?

#define MAX_SIZE 1024

static void initRandom(int list[], int n, int max);
static void PrintArray(int arr[], int n, const char* str);

// 합병 정렬에서 실제로 정렬이 이루어지는 시점은 2개의 리스트를 합병 하는 단계이다
// 합병은 2개의 리스트의 요소들을 처음부터 하나씩 비교하여 두 요소 중에서 더 작은 요소를 새로운 리스트로 옮긴다
// 두 리스트 중에서 하나가 모두 끝날 때 까지 이 과정을 반복한다
// 하나의 리스트가 먼저 끝나면 나머지 리스트의 요소들을 전부 새로운 리스트로 복사한다
// 이러한 합병 과정은 어렵지는 않으나 추가적인 리스트를 필요로 한다

// 이 알고리즘에서는 하나의 배열에 두 개의 정렬된 부분 리스트가 저장되어 있다가 가정하였다
// 즉, 첫 번째 부분 리스트는 A[left] 부터 A[mid] 까지이고 (왼쪽)
// 두 번째 부분 리스트는 A[mid + 1] 부터 A[right] 까지이다 (오른쪽)
// 합병된 리스트를 임시로 저장하기 위해 배열 sorted를 사용한다

// 합병 정렬 알고리즘을 구현하면 책 363p 에 있는 이진 탐색 트리 클래스와 같다

// mergeSort 함수에서 주어진 A 배열을 2등분하여 각각의 부분 배열에 대하여 다시 mergeSort 함수를 순환 호출한다
// 이러한 과정은 결국 부분 배열에 숫자가 하나 남을 때까지 계속된다
// 분할 과정이 끝나면 정렬된 부분 배열을 merge 함수를 이용하여 합병하는 과정이 시작된다
// merge 함수는 부분 배열들의 숫자를 임시 배열에 정렬된 상태로 만든 다음, 다시 원래의 배열에 복사한다
static void merge(int A[], int left, int mid, int right)
{
	int i;
	int j;
	int k = left; // 정렬될 리스트에 대한 인덱스
	int l;
	static int sorted[MAX_SIZE];

	// 분할 정렬된 A의 합병
	for (i = left, j = mid + 1; i <= mid && j <= right;)
	{
		sorted[k++] = (A[i] <= A[j]) ? A[i++] : A[j++];
	}

	// 한쪽에 남아 있는 레코드의 일괄 복사
	if (i > mid)
	{
		for (l = j; l <= right; l++, k++)
		{
			sorted[k] = A[l];
		}
	}
	else
	{
		for (l = i; l <= mid; l++, k++)
		{
			sorted[k] = A[l];
		}
	}

	// 배열 sorted[] 의 리스트를 배열 A[]로 재복사
	for (l = left; l <= right; l++)
	{
		A[l] = sorted[l];
	}
}

// 합병 정렬 알고리즘을 이용해 int 배열을 오름차순으로 정렬하는 함수
// 순환(재귀 함수)을 이용하여 배열을 쪼갤 수 없을 때까지 쪼개고 그것을 차례대로 합병(정렬)한다

// mergeSort 함수에서 주어진 A 배열을 2등분하여 각각의 부분 배열에 대하여 다시 mergeSort 함수를 순환 호출한다
// 이러한 과정은 결국 부분 배열에 숫자가 하나 남을 때까지 계속된다
// 분할 과정이 끝나면 정렬된 부분 배열을 merge 함수를 이용하여 합병하는 과정이 시작된다
// merge 함수는 부분 배열들의 숫자를 임시 배열에 정렬된 상태로 만든 다음, 다시 원래의 배열에 복사한다
void mergeSort(int A[], int left, int right)
{
	if (left < right)
	{
		// 리스트의 균등 분할
		int mid = (left + right) / 2;
		// 부분 리스트 정렬 (왼쪽)
		mergeSort(A, left, mid);
		// 부분 리스트 정렬 (오른쪽)
		mergeSort(A, mid + 1, right);
		// 합병
		merge(A, left, mid, right);
	}
}

// 랜덤 함수를 이용하여 int 배열을 0 ~ max-1 의 값으로 무작위로 채우는 함수
// static 으로 선언하여 캡슐화 하였다 (static 으로 선언된 함수는 선언한 파일안에서만 사용할 수 있다)
static void initRandom(int list[], int n, int max = 100)
{
	for (int i = 0; i < n; i++)
	{
		list[i] = rand() % max;
	}
}

// 배열을 화면에 보기 좋게 출력하는 함수, 디폴트 매개변수 사용
// static 으로 선언하여 캡슐화 하였다 (static 으로 선언된 함수는 선언한 파일안에서만 사용할 수 있다)
static void PrintArray(int arr[], int n, const char* str = "Array")
{
	printf("%s = ", str);

	for (int i = 0; i < n; i++)
		printf("%3d", arr[i]);

	printf("\n");
}

// 정렬 알고리즘 테스트를 위한 주 함수
int main()
{
	int list[5] = { 8,2,1,7,5 };
	int n = 5;

	//initRandom(list, n);
	// 정렬 전 배열 내용을 출력
	PrintArray(list, n, "Original ");
	// 선택 정렬 알고리즘 실행
	mergeSort(list, 0, n - 1);
	// 정렬 후 배열 내용을 출력
	PrintArray(list, n, "Selection");

	return 0;
}