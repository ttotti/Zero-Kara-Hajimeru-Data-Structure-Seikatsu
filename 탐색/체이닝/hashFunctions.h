#pragma once

// 다음 코드는 문자열 탐색키의 정수 변환 및 해시 함수의 예 이다

// 해싱 테이블의 크기 (예: 소수 13을 사용)
#define TABLE_SIZE 13

// 문자열로 된 탐색키를 숫자로 변환 : 간단한 덧셈 방식

// 탐색키 : "do",  덧셈식 변환(reansform()) : 아스키코드 사용 ('d')100 + ('o')111 = 211,  해시 주소 : 211 % 13 = 3
inline int transform(const char* key)
{
	int number = 0;

	while (*key)
	{
		number += (*key++);
	}

	return number;
}

// 해싱 함수: 제산 함수 사용
inline int hashFunction(const char* key)
{
	return transform(key) % TABLE_SIZE;
}




// 해시 함수
// 좋은 해시 함수의 조건은 다음의 3가지이다
/*
	1. 충돌이 적어야 한다
	2. 해시 함수 값이 해시 테이블의 주소 영역 내에서 고르게 분포되어야 한다
	3. 계산이 빨라야 한다
*/

// 예를 들면 영어 단어의 첫 문자만을 취하여 해시 함수로 사용하는 것은 좋지 않다
// 왜냐 하면 x나 z로 시작하는 단어는 별로 없기 때문이다
// 즉, 이 경우 해시 테이블을 균일하게 사용하지 않는다
// 먼저 탐색키가 정수라고 가정하고 해시 함수들을 살펴보자

// 제산 함수
/*
	가장 일반적인 방법이 나머지 연산자 mod(% 연산자) 를 사용하는 것이다
	테이블의 크기가 M일 때 탐색키 k 에 대하여 해시 함수는 다음과 같다

	h(k) = k mod M

	이때 가능하면 해시 주소를 더 고르게 분포시키기 위해 해시 테이블의 크기 M은 소수를 선택한다
	즉, 1과 자신만을 약수로 가지는 수라면 k mod M 은 0에서 M-1을 골고루 사용하는 값을 만들어낸다
*/

// 폴딩 함수
/*
	폴딩 함수는 주로 탐색키가 해시 테이블의 크기보다 더 큰 정수일 경우에 사용된다
	예를 들어, 탐색키는 32비트이고 해시 테이블의 인덱스는 16비트 정수인 경우이다
	만약 이런 경우 탐색키의 앞의 16비트를 무시하고 뒤의 16비트를 해시 코드로 사용한다면
	앞의 16비트만 다르고 뒤의 16비트는 같은 탐색키의 경우, 충돌이 발생할 것이다
	따라서 탐색키의 일부만 사용하는 것이 아니고 탐색키를 몇 개의 부분으로 나누어 이를 더하거나 비트별로 XOR 같은 불 연산을 하는 것이 보다 좋은 방법이다
	이것을 폴딩(folding) 이라고 한다

	예를 들어 32비트 키를 2개의 16비트로 나우어 비트멸로 XOR 연산을 하는 코드는 다음과 같다

	hash_index = (short)(key ^ (key>>16))

	폴딩 함수는 탐색키를 여러 부분으로 나누어 모두 더한 값을 해시 주소로 사용한다
	탐색키를 나누고 더하는 방법에는 이동 폴딩(shift folding)과 경계 폴딩(doundary folding)이 대표적이다

	이동 폴딩은 탐색키를 여러 부분으로 나눈 값을 더하고,
	경계 폴딩은 이웃한 부분을 거꾸로 더해 해시 주소를 얻는다
	
	예)
	탐색키 : 123|203|241|112|20

	이동 폴딩 : 123 + 203 + 241 + 112 + 20 = 699

	경계 폴딩 : 123 + 302 + 241 + 211 + 20 = 897
	                 (203)       (112)
*/

// 중간 제곱 함수
/*
	중간 제곱 함수는 탐색키를 제곱한 다음, 중간의 몇 비트를 취해서 해시 주소를 생성한다
	제곱한 값의 중간 비트들은 대개 탐색키의 모든 문자들과 관련이 있기 때문에 서로 다른 탐색키는 몇 개의 문자가 같을 지라도 서로 다른 해싱 주로를 갖게 된다, 
	탐색키 값을 제곱한 값의 중간 비트들의 값은 비교적 고르게 분산된다
*/

// 비트 추출 방법
/*
	해시 테이블의 크기가 M = 2^k 일 때 탐색키를 이진수로 간주하여 임의의 위치의 k개의 비트를 해시 주소로 사용하는 것이다
	이 방법은 아주 간단하지만 탐색키의 일부 정보만을 사용하므로 해시 주소의 집중 현상이 일어날 가능성이 높다
*/

// 숫자 분석 방법
/*
	이 방법은 숫자로 구성된 키에서 각 위치마다 수의 특징을 미리 알고 있을 때 유용하다
	키의 각각의 위치에 있는 숫자 중에서 편중되지 않는 수들을 해시 테이블의 크기에 적합한 만큼 조합하여 해시 주소로 사용하는 방법이다
	예를 들어, 학생의 학번이 201512345 라 한다면 
	입학년도를 의미하는 앞의 4자릿수는 편중되어 있으므로 가급적 사용하지 않고 나머지 수를 조합하여 해시 주소로 사용한다
*/

// 탐색키가 문자열인 경우
/*
	탐색키가 문자열인 경우는 보통 각 문장에 정수를 대응시켜 바꾸게 된다
	예를 들면 'a' 부터 'z' 에 1부터 26을 할당할 수도 있고
	각 문자의 아스키 코드나 유니코드 값을 그대로 이용할 수도 있다
	가능하면 문자열 안의 모든 문자를 골고루 사용하는 것이 좋을 것이다
*/
