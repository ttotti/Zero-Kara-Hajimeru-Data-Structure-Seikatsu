#include "HashMap.h"

void main()
{
	HashMap hash;

	hash.addLinearProb("do", "반복");
	hash.addLinearProb("for", "반복");
	hash.addLinearProb("if", "분기");
	hash.addLinearProb("case", "분기");
	hash.addLinearProb("else", "분기");
	hash.addLinearProb("return", "반환");
	hash.addLinearProb("funtion", "함수");

	hash.display();

	hash.searchLinearProb("return");
	hash.searchLinearProb("class");
	hash.searchLinearProb("funtion");
}

// 지금 까지 공부한 방법들은 탐색키가 주어지면 테이블에 있는 각 자료들의 키값과 비교하여 원하는 레코드를 찾는 방법어었다
// 해싱은 키값을 비교하는 것이 아니라 탐색키에 산술적인 연산을 적용하여 항목이 저장되어 있는 위치
// 즉 인덱스를 직접 계산하는 방식이다
// 이렇게 키값의 연산에 의해 직접 접근이 가능한 구조를 해싱 테이블(hash table) 이라 하며
// 해시 테이블을 이용한 탐색을 해싱(hashing) 이라 한다

// 예를 들어 탐색키들이 모두 1~1000 사이의 정수라고 가정하면
// 가장 빠르게 자료를 저장하고 꺼낼 수 있는 방법은 1000개의 요소를 가지는 배열을 만드는 것이다
// 자료의 삽입과 탐색은 탐색키를 배열의 인덱스로 생각하고 단지 배열의 특정 요소를 읽거나 쓰면 된다
// 이들 연산은 명백하게 O(1) 이다, 이것이 해싱의 기본 아이디어 이다

// 현실적으로는 탐색키들이 문자열이거나 굉장히 큰 숫자이기 때문에 탐색키를 직접적으로 배열의 인덱스로 사용하지 못하고
// 각 탐색키를 작은 정수로 사상(mapping) 시키는 어떤 함수가 필요하다, 이를 해시 함수(hash function) 라고 한다
// 해시 함수는 탐색키를 입력 받아 해시 주소(hash address)를 계산하는데, 삽입이나 삭제, 탐색 연산은 모두 이 주소에서 이루어진다

// 키값 k를 입력받아 해시 함수로 연산한 결과인 해시 주소 h(k) 를 인덱스로 사용하여 해시 테이블에 있는 항목에 접근한다
// 해시 테이블ht 는 M개의 버켓(bucket) 으로 이루어지는 테이블이고,
// 하나의 버켓에는 각각 레코드를 저장 할 수 있는 여러 개의 슬롯(slot)을 가진다
// 이것은 여러 개의 탐색키가 동일한 해시 주소로 변환될 수 있기 때문인데, 여기서는 슬롯이 하나라고 생각하자

// 해시 테이블의 버켓의 수가 제한적이므로 경우에 따라 서로 다른 키 k1과 k2가 해시함수에 의해 같은 주소,
// 즉 h(k1) == h(k2) 로 계산되는 상황이 발생한다, 이것을 충돌(collision) 이라고 하고 이러한 키 k1과 k2를 동의어(synonym) 라 한다

// 충돌이 발생하면 버켓에 여러 개의 슬롯이 있다면 k1과 k2를 각각 다른 슬롯에 저장하면 된다
// 그러나 슬롯 수보다 더 많이 발생할 수도 있는데, 이러한 상황을 오버플로우(overflow) 라고 한다
// 이 경우 해당 버켓에 더 이상 항목을 저장할 수 없게 된다, 따라서 해싱에서는 오버플로우를 해결하기 위한 방법이 반드시 필요하다